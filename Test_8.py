# 1. Реализовать класс «Дата», функция-конструктор которого должна принимать дату в виде строки формата «день-месяц-год».
# В рамках класса реализовать два метода.
# Первый, с декоратором @classmethod, должен извлекать число, месяц, год и преобразовывать их тип к типу «Число».
# Второй, с декоратором @staticmethod, должен проводить валидацию числа  (verification, validation), месяца и года (например, месяц — от 1 до 12).
# Проверить работу полученной структуры на реальных данных.

class My_date:

    def __init__(self, date):
        self.date = date

    @classmethod
    def get_date(csl, date):
        new_date_format_list = []
        '''
            Функция принимает дату в формате дд.мм.гггг.
            Извлекает из строкового значения чиловое значание дд, мм, ггг.
            Возвращает список с тремя числовыми значениями расположенными последовательно: дд, мм, ггг.
        '''
        for num in date.split('.'):
            new_date_format_list.append(int(num))
        return new_date_format_list

    @staticmethod
    def get_validation(date_list):
        '''
        Функция принимает результат работы функции get_date () (список).
        Проверяет значения  0 < дд <= 31
                            0 < мм  <= 12
                            0 < гг .
        Вазвращает 'Данные верны' или 'Данные не верны'.
        '''
        dd = date_list[0]
        mm = date_list[1]
        yy = date_list[2]
        if 0 < dd <= 31 and 0 < mm  <= 12 and 0 < yy:
            return 'Данные верны'
        return 'Данные не верны'

date = My_date.get_date('23.89.2020')
print(date)
print(My_date.get_validation(date))
date = My_date.get_date('23.09.2020')
print(date)
print(My_date.get_validation(date))

# 2. Создайте собственный класс-исключение, обрабатывающий ситуацию деления на нуль.
# Проверьте его работу на данных, вводимых пользователем. При вводе пользователем нуля в
# качестве делителя программа должна корректно обработать эту ситуацию и не завершиться с ошибкой.



class My_exception:

    @classmethod
    def div(cls,a, b):
        try:
            return a / b
        except ZeroDivisionError:
            return "На ноль делить нельзя"

print(My_exception.div(5,0))
print(My_exception.div(5,2))

# 3. Создайте собственный класс-исключение, который должен проверять содержимое списка на
# наличие только чисел. Проверить работу исключения на реальном примере. Необходимо запрашивать
# у пользователя данные и заполнять список. Класс-исключение должен контролировать типы данных элементов списка.
# Примечание: длина списка не фиксирована. Элементы запрашиваются бесконечно, пока пользователь сам не
# остановит работу скрипта, введя, например, команду “stop”. При этом скрипт завершается, сформированный
# список выводится на экран.
# Подсказка: для данного задания примем, что пользователь может вводить только числа и строки. При вводе
# пользователем очередного элемента необходимо реализовать проверку типа элемента и вносить его в список,
# только если введено число. Класс-исключение должен не позволить пользователю ввести текст (не число) и
# отобразить соответствующее сообщение. При этом работа скрипта не должна завершаться.



class My_control:




    @classmethod
    def my_input(cls):
        my_list = []
        while True:
            try:
                val = int(input('Введите число и нажмите ввод - '))
                my_list.append(val)
            except:
                print("Вы ввели строковое значение")
                y_or_n = input('Продолжить нажмите Ввод  ,  завершить  ввод N :')
                if y_or_n == 'N' or y_or_n == 'n':
                    return my_list
        else:
            return my_list



print(My_control.my_input())


# 4. Начните работу над проектом «Склад оргтехники». Создайте класс, описывающий склад.
# А также класс «Оргтехника», который будет базовым для классов-наследников. Эти классы —
# конкретные типы оргтехники (принтер, сканер, ксерокс). В базовом классе определить параметры,
# общие для приведенных типов. В классах-наследниках реализовать параметры, уникальные для каждого типа оргтехники.
# 5. Продолжить работу над первым заданием. Разработать методы, отвечающие за приём оргтехники на
# склад и передачу в определенное подразделение компании. Для хранения данных о наименовании и
# количестве единиц оргтехники, а также других данных, можно использовать любую подходящую структуру,
# например словарь.
# 6. Продолжить работу над вторым заданием. Реализуйте механизм валидации вводимых пользователем
# данных. Например, для указания количества принтеров, отправленных на склад, нельзя использовать
# строковый тип данных.
# Подсказка: постарайтесь по возможности реализовать в проекте «Склад оргтехники» максимум возможностей,
# изученных на уроках по ООП.

class Store:

    @classmethod
    def my_inpute(cls):
        my_unit = []
        unique = {}

        while True:
            try:
                unit = input(f'Введите наименование товара: ')
                unit_price = int(input(f'Введите цену за ед {unit} '))
                unit_quantity = int(input(f'Введите количество {unit} '))
                unique = {'Модель устройства ': unit, 'Цена за ед ': unit_price, 'Количество ': unit_quantity}
                my_unit.append(unique)
                print(f'Отправили на склад - {my_unit}')
                my_store.append(my_unit)
            except:
                print('Ошибка ввода данных')
                if input('Оставить ввод Q, Продолжить Ввод') == 'Q' or 'q':
                    quit()
            finally:
                return my_store

    @classmethod
    def my_outpute(cls):
        while True:
            try:
                unit = input('Введите наименование товара: ')
                my_store.remove(unit)
            except:
                print('Ошибка ввода данных')
                if input('Оставить ввод Q, Продолжить Ввод') == 'Q' or 'q': quit(0)


class Printer(Store):
    def __init__(self, name, price, quantity, *args):
        super().__init__(name, price, quantity, *args)


class Scaner(Store):
    def __init__(self, name, price, quantity, *args):
        super().__init__(name, price, quantity, *args)


class Copir(Store):
    def __init__(self, name, price, quantity, *args):
        super().__init__(name, price, quantity, *args)

Printer.my_inpute()
Scaner.my_inpute()
Copir.my_inpute()
Printer.my_outpute()


# 7. Реализовать проект «Операции с комплексными числами». Создайте класс «Комплексное число»,
# реализуйте перегрузку методов сложения и умножения комплексных чисел. Проверьте работу проекта,
# создав экземпляры класса (комплексные числа) и выполнив сложение и умножение созданных экземпляров.
# Проверьте корректность полученного результата.



class Complex_number:
    def __init__(self, a, b, *args):
        self.a = a
        self.b = b
        self.z = 'a + b * j'

    def __add__(self, other):
        return f'z = {self.a + other.a} + {self.b + other.b} * j'

    def __mul__(self, other):
        return f'z = {self.a * other.a - (self.b * other.b)} + {self.b * other.a} * j'

    def __str__(self):
        return f'z = {self.a} + {self.b} * j'


z_1 = Complex_number(1, 8)
z_2 = Complex_number(3, 4)

print(z_1 + z_2)
print(z_1 * z_2)